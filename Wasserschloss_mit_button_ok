/* Version 22 - cleanup version
Bernhard Pleschko, Makers im Zigerschlitz, 9.10.2025
Animation für das Wasserschloss mit ESP32
Es werden 4 Fälle gezeigt, gesteuert durch HIGH Signal auf dem jeweiligen Pin:
* Input 1 = Wasser schwankt nach oben 
* Input 2 = Wasser schwankt nach unten 
* Input 3 = Wasser schwankt stark nach oben 
* Input 4 = Wasser schwankt stark nach unten
Dazwischen wird jeweils dasselbe Ruheniveau eingestellt.

Sperre für alle Tasten wenn eine Taste aufgerufen ist und das Programm läuft ist in der Animation automatisch inkludiert
*/

#include <FastLED.h> //Library für LED Matrix
#include <math.h>    //Library für Winkelfunktionen (cos)

// --- Debugging Toggle ---
#define DEBUG_MODE true // auf false setzen für die finale version (no Serial output)

#if DEBUG_MODE
  #define DEBUG_BEGIN(x)    Serial.begin(x)
  #define DEBUG_PRINT(x)    Serial.print(x)
  #define DEBUG_PRINTLN(x)  Serial.println(x)
#else
  #define DEBUG_BEGIN(x)
  #define DEBUG_PRINT(x)
  #define DEBUG_PRINTLN(x)
#endif

// --- Hardware Konfiguration ---
#define LED_PIN     16          // ESP32 Pin für die Datenleitung der LED Matrix
#define WIDTH       8           // Matrix Breite
#define HEIGHT      64          // Matrix Höhe (volle 64 Reihen, 2x32 in Reihe)
#define NUM_LEDS    WIDTH * HEIGHT  // Gesamte Anzahl LEDs

// --- ESP32 Pins für die Tastensteuerung ---
const int buttonPins[] = {17, 18, 19, 21}; // Pin17 für Input 1, Pin18 für Input 2, Pin 19 für Input 3, Pin21 für Input 4

// --- Debouncing Variablen für jede Taste ---
unsigned long lastDebounceTime[] = {0, 0, 0, 0};
int lastButtonState[] = {HIGH, HIGH, HIGH, HIGH}; // Letzter *stabiler* Zustand des Buttons
int buttonReadingState[] = {HIGH, HIGH, HIGH, HIGH}; // Aktueller *gemessener* Zustand (wird debounced)
const long debounceDelay = 50; // Millisekunden

// --- LED Matrix und Helligkeit ---
CRGB leds[NUM_LEDS];
#define BRIGHTNESS  100       // Helligkeit
#define DELAY_TIME  20        // Verzögerungszeit für Animationen

// --- Animations-Variablen ---
const int wsNiveau_Ruhe = 40;   // Wasserniveau im Ruhezustand (Basishöhe der Säule)
int currentSchwingungsHoehe = wsNiveau_Ruhe;

enum AnimationState {   //Zuweisung der Zustände Ruhe und 1-4
  STATE_IDLE,
  STATE_OSCILLATE_UP_SOFT,
  STATE_OSCILLATE_DOWN_SOFT,
  STATE_OSCILLATE_UP_STRONG,
  STATE_OSCILLATE_DOWN_STRONG
};

AnimationState currentAnimationState = STATE_IDLE; // Start im Ruhezustand

// --- Flag für die einmalige Initialisierung im Loop ---
bool initialMatrixSetupDone = false;

// --- Funktions-Prototypen für alle Hilfsfunktionen---
void lightRow(int row);
void clearRow(int row);
int getMatrixIndex(int col, int row);
void dampenedOscillation_down(int input_amplitude);
void dampenedOscillation_up(int input_amplitude);

void setup() {
  delay(100); //kurzes Delay für sicheren Start mit externer Stromversorgung
  DEBUG_BEGIN(115200);

  for (int i = 0; i < 4; i++) {
    pinMode(buttonPins[i], INPUT_PULLUP); // Achung: Buttons sind mit PULLUP konfiguriert, Anschluss nur GND und ButtonPin
  }

  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(BRIGHTNESS);
  
  currentAnimationState = STATE_IDLE;
}

void loop() {
  // --- Einmalige Initialisierung der Matrix und Anzeige des Ruhezustandes
  if (!initialMatrixSetupDone) {    //Überprüfung ob erste Initialisierung schon durchgeführt ist, wird bei weiteren Durchläufen übersprungen
    FastLED.clear();
    for (int row = 0; row < wsNiveau_Ruhe; row++) {
        for (int col = 0; col < WIDTH; col++) {
            leds[getMatrixIndex(col, row)] = CRGB::Blue;
        }
    }
    FastLED.show();
    initialMatrixSetupDone = true;
    delay(1000);
  }

  // Debug-Ausgabe alle 2 Sekunden für den Loop, inklusive des aktuellen Animationszustands
  static unsigned long lastLoopPrint = 0;
  if (millis() - lastLoopPrint > 2000) {
    lastLoopPrint = millis();
    DEBUG_PRINT("Loop läuft. Aktueller Zustand (currentAnimationState): ");
    DEBUG_PRINTLN(currentAnimationState);
  }

  // --- Tastenabfrage und Robustes Debouncing ---
  for (int i = 0; i < 4; i++) {
    int reading = digitalRead(buttonPins[i]); // Aktueller roher Pin-Zustand

    // Wenn der rohe Pin-Zustand anders ist als der "vorläufige" Zustand
    if (reading != buttonReadingState[i]) {
      lastDebounceTime[i] = millis(); // Setze Debounce-Timer neu
      buttonReadingState[i] = reading; // Aktualisiere den "vorläufigen" Zustand
      DEBUG_PRINT("DEBUG: Button "); DEBUG_PRINT(i + 1); DEBUG_PRINT(" raw reading changed to: "); DEBUG_PRINTLN(reading);
    }

    // Wenn seit dem letzten Wechsel des "vorläufigen" Zustands genug Zeit vergangen ist
    if ((millis() - lastDebounceTime[i]) > debounceDelay) {
      // Wenn der "vorläufige" Zustand sich vom *stabilen* Zustand unterscheidet
      if (buttonReadingState[i] != lastButtonState[i]) { // Stabiler Zustandswechsel erkannt

        // Animation nur starten, wenn die Taste von LOW auf HIGH wechselt (LOSLASSEN)
        if (buttonReadingState[i] == HIGH && lastButtonState[i] == LOW) { // Button ist jetzt STABIL NICHT GEDRÜCKT (HIGH), und war vorher GEDRÜCKT (LOW)
          DEBUG_PRINT("DEBUG: Taste "); DEBUG_PRINT(i + 1); DEBUG_PRINTLN(" LOSGELASSEN (STABIL nach Debounce).");
          DEBUG_PRINT("DEBUG: currentAnimationState: "); DEBUG_PRINT(currentAnimationState);
          DEBUG_PRINT(" (STATE_IDLE ist "); DEBUG_PRINT(STATE_IDLE); DEBUG_PRINTLN(")");

          if (currentAnimationState == STATE_IDLE) {
            DEBUG_PRINTLN("TRUE - SOLLTE JETZT ANIMATION STARTEN.");
            switch (i) {
              case 0:
                currentSchwingungsHoehe = 8;
                currentAnimationState = STATE_OSCILLATE_UP_SOFT;
                DEBUG_PRINTLN("ACTION: Taste 1 gedrückt: Sanft UP");
                break;
              case 1:
                currentSchwingungsHoehe = 8;
                currentAnimationState = STATE_OSCILLATE_DOWN_SOFT;
                DEBUG_PRINTLN("ACTION: Taste 2 gedrückt: Sanft DOWN");
                break;
              case 2:
                currentSchwingungsHoehe = 13;
                currentAnimationState = STATE_OSCILLATE_UP_STRONG;
                DEBUG_PRINTLN("ACTION: Taste 3 gedrückt: Stark UP");
                break;
              case 3:
                currentSchwingungsHoehe = 13;
                currentAnimationState = STATE_OSCILLATE_DOWN_STRONG;
                DEBUG_PRINTLN("ACTION: Taste 4 gedrückt: Stark DOWN");
                break;
            }
            DEBUG_PRINT("DEBUG: Animation für Button "); DEBUG_PRINT(i + 1); DEBUG_PRINT(" angefordert. Neuer Zustand: "); DEBUG_PRINTLN(currentAnimationState);
          } else {
              DEBUG_PRINT("DEBUG: Bedingung 'currentAnimationState == STATE_IDLE' ist: FALSE - Taste ignoriert. Aktueller Zustand: ");
              DEBUG_PRINTLN(currentAnimationState);
          }
        }
        lastButtonState[i] = buttonReadingState[i]; // Aktualisiere den stabilen Zustand
      }
    }
  }

  // --- Steuerung der Animationen basierend auf dem aktuellen Zustand ---
  switch (currentAnimationState) {
    case STATE_IDLE:
      // Im Ruhezustand passiert hier nichts.
      break;

    case STATE_OSCILLATE_UP_SOFT:
    case STATE_OSCILLATE_UP_STRONG:
      dampenedOscillation_up(currentSchwingungsHoehe); // Animation abspielen
      currentAnimationState = STATE_IDLE;             // Nach Beendigung zurück in den Ruhezustand
      DEBUG_PRINTLN("DEBUG: Animation UP beendet. Zurück im Ruhezustand.");
      break;

    case STATE_OSCILLATE_DOWN_SOFT:
    case STATE_OSCILLATE_DOWN_STRONG:
      dampenedOscillation_down(currentSchwingungsHoehe); // Animation abspielen
      currentAnimationState = STATE_IDLE;               // Nach Beendigung zurück in den Ruhezustand
      DEBUG_PRINTLN("DEBUG: Animation DOWN beendet. Zurück im Ruhezustand.");
      break;
  }
  delay(10); // Kleiner Delay, damit der Serial Monitor nicht überläuft.
}

// --- HILFSFUNKTIONEN ---

int getMatrixIndex(int col, int row) {
  return row * WIDTH + col;
}

void lightRow(int targetRow) {
  for (int col = 0; col < WIDTH; col++) {
    if (targetRow >= 0 && targetRow < HEIGHT) {
      leds[getMatrixIndex(col, targetRow)] = CRGB::Blue;
    }
  }
  FastLED.show();
}

void clearRow(int targetRow) {
  for (int col = 0; col < WIDTH; col++) {
    if (targetRow >= 0 && targetRow < HEIGHT) {
      leds[getMatrixIndex(col, targetRow)] = CRGB::Black;
    }
  }
  FastLED.show();
}

void dampenedOscillation_down(int input_amplitude) {
  float alpha = 0.0;
  float current_decaying_amplitude = input_amplitude; // Diese Amplitude wird jetzt gedämpft
  float dampingFactor = 0.135; // NEU: Steuert die Dämpfungsstärke (0.01 für sehr langsam, 0.1 für schnell)

  DEBUG_PRINT("INFO: Starte dampenedOscillation_down mit Amplitude: ");
  DEBUG_PRINTLN(input_amplitude);

  int maxIterations = 200;
  int iterationCount = 0;

  // Die Schleife läuft, solange die aktuelle, abklingende Amplitude über 0.5 ist
  while (current_decaying_amplitude > 0.5 && iterationCount < maxIterations) {
    // Die momentane Höhe der Welle wird aus der abklingenden Amplitude und cos(alpha) berechnet
    float instantaneous_oscillation_height = current_decaying_amplitude * cos(alpha);
    if (instantaneous_oscillation_height < 0) instantaneous_oscillation_height = -instantaneous_oscillation_height; // Amplitude immer positiv halten

    int highLevel = wsNiveau_Ruhe + round(instantaneous_oscillation_height);
    int lowLevel = wsNiveau_Ruhe - round(instantaneous_oscillation_height);

    highLevel = constrain(highLevel, 0, HEIGHT - 1);
    lowLevel = constrain(lowLevel, 0, HEIGHT - 1);

    for (int row = wsNiveau_Ruhe -1; row >= lowLevel; row--) {
      clearRow(row);
      delay(DELAY_TIME);
    }
    for (int row = lowLevel; row <= wsNiveau_Ruhe; row++) {
      lightRow(row);
      delay(DELAY_TIME);
    }
    for (int row = wsNiveau_Ruhe +1; row <= highLevel; row++) {
      lightRow(row);
      delay(DELAY_TIME);
    }
    for (int row = highLevel; row >= wsNiveau_Ruhe; row--) {
      clearRow(row);
      delay(DELAY_TIME);
    }

    alpha += 0.1; // Erhöht den Winkel für die nächste Phase der Schwingung
    // Hier wird die Amplitude tatsächlich gedämpft!
    current_decaying_amplitude *= (1.0 - dampingFactor); // Reduziert die Amplitude um einen Faktor
    iterationCount++;
  }
  DEBUG_PRINT("INFO: dampenedOscillation_down beendet nach "); DEBUG_PRINT(iterationCount); DEBUG_PRINTLN(" Iterationen.");

  FastLED.clear();
  for (int row = 0; row < wsNiveau_Ruhe; row++) {
      for (int col = 0; col < WIDTH; col++) {
          leds[getMatrixIndex(col, row)] = CRGB::Blue;
      }
  }
  FastLED.show();
  DEBUG_PRINTLN("INFO: Ruhe-Niveau wiederhergestellt.");
}

void dampenedOscillation_up(int input_amplitude) {
  float alpha = 0.0;
  float current_decaying_amplitude = input_amplitude; // Diese Amplitude wird jetzt gedämpft
  float dampingFactor = 0.135; // NEU: Steuert die Dämpfungsstärke (0.01 für sehr langsam, 0.1 für schnell)

  DEBUG_PRINT("INFO: Starte dampenedOscillation_up mit Amplitude: ");
  DEBUG_PRINTLN(input_amplitude);

  int maxIterations = 200;
  int iterationCount = 0;

  // Die Schleife läuft, solange die aktuelle, abklingende Amplitude über 0.5 ist
  while (current_decaying_amplitude > 0.5 && iterationCount < maxIterations) {
    // Die momentane Höhe der Welle wird aus der abklingenden Amplitude und cos(alpha) berechnet
    float instantaneous_oscillation_height = current_decaying_amplitude * cos(alpha);
    if (instantaneous_oscillation_height < 0) instantaneous_oscillation_height = -instantaneous_oscillation_height; // Amplitude immer positiv halten

    int highLevel = wsNiveau_Ruhe + round(instantaneous_oscillation_height);
    int lowLevel = wsNiveau_Ruhe - round(instantaneous_oscillation_height);

    highLevel = constrain(highLevel, 0, HEIGHT - 1);
    lowLevel = constrain(lowLevel, 0, HEIGHT - 1);

    for (int row = wsNiveau_Ruhe + 1; row <= highLevel; row++) {
      lightRow(row);
      delay(DELAY_TIME);
    }
    for (int row = highLevel; row >= wsNiveau_Ruhe; row--) {
      clearRow(row);
      delay(DELAY_TIME);
    }
    for (int row = wsNiveau_Ruhe - 1; row >= lowLevel; row--) {
      clearRow(row);
      delay(DELAY_TIME);
    }
    for (int row = lowLevel; row <= wsNiveau_Ruhe; row++) {
      lightRow(row);
      delay(DELAY_TIME);
    }

    alpha += 0.1; // Erhöht den Winkel für die nächste Phase der Schwingung
    // Hier wird die Amplitude tatsächlich gedämpft!
    current_decaying_amplitude *= (1.0 - dampingFactor); // Reduziert die Amplitude um einen Faktor
    iterationCount++;
  }
  DEBUG_PRINT("INFO: dampenedOscillation_up beendet nach "); DEBUG_PRINT(iterationCount); DEBUG_PRINTLN(" Iterationen.");

  FastLED.clear();
  for (int row = 0; row < wsNiveau_Ruhe; row++) {
      for (int col = 0; col < WIDTH; col++) {
          leds[getMatrixIndex(col, row)] = CRGB::Blue;
      }
  }
  FastLED.show();
  DEBUG_PRINTLN("INFO: Ruhe-Niveau wiederhergestellt.");
}
